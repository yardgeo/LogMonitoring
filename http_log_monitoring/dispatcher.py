import asyncio
import logging

from config import Config
from consumers import ConsoleNotificationConsumer
from hadnlers import HighTrafficAlertHandler, TrafficStatsHandler
from producers import LocalCSVFileHttpLogProducer


class Dispatcher:
    """
    A class to represent dispatcher logic.
    Dispatcher start producers, consumers and handlers as asyncio tasks and manage their lifetime.
    """
    def __init__(self,
                 log_file_path: str = None):
        # init loop
        self._loop = asyncio.get_event_loop()
        self._logger = logging.getLogger()

        # init local producer
        if log_file_path is None:
            log_file_path = Config.LOCAL_PRODUCER_FILEPATH
        self._producer = LocalCSVFileHttpLogProducer(log_file_path)

        # init consumers
        self._notification_consumer = ConsoleNotificationConsumer()

        # init handlers
        self._handlers = [
            HighTrafficAlertHandler(
                notification_consumer=self._notification_consumer,
                log_handler_queue=asyncio.Queue(loop=self._loop)
            ),
            TrafficStatsHandler(
                notification_consumer=self._notification_consumer,
                log_handler_queue=asyncio.Queue(loop=self._loop))
        ]

    async def _handle_logs(self) -> None:
        """
        Iterate over stream of logs which are generated by producer. Handle each log by each handler
        """
        async for log_line in self._producer.stream_logs():
            for handler in self._handlers:
                await handler.handle(log_line)

    def _close_all(self) -> None:
        """
        Close all tasks
        """
        try:
            to_cancel = asyncio.all_tasks(self._loop)
            if not to_cancel:
                return
            # cancel all tasks
            for task in to_cancel:
                task.cancel()

            self._loop.run_until_complete(
                asyncio.gather(*to_cancel, loop=self._loop, return_exceptions=True))

            for task in to_cancel:
                if task.cancelled():
                    continue
                if task.exception() is not None:
                    self._loop.call_exception_handler({
                        'message': 'unhandled exception during test shutdown',
                        'exception': task.exception(),
                        'task': task,
                    })
            # shutdown asyncgens
            self._loop.run_until_complete(self._loop.shutdown_asyncgens())
        finally:
            asyncio.set_event_loop(None)
            self._loop.close()

    def _start_all(self) -> None:
        """
        Start all tasks in parallel mode
        """
        # generate tasks array
        tasks = [self._producer.start, self._notification_consumer.start, self._handle_logs]
        tasks.extend([handler.start for handler in self._handlers])

        # run in parallel
        try:
            self._loop.run_until_complete(
                asyncio.gather(
                    *[task() for task in tasks],
                    return_exceptions=True
                )
            )
        # program is closed
        except KeyboardInterrupt:
            self._logger.info("Monitoring program is stopped by user. Quitting...")
        # close all
        finally:
            self._close_all()

    def run(self) -> None:
        """
        Start dispatcher
        """
        self._start_all()
