import asyncio
import logging

from config import Config
from consumers import ConsoleNotificationConsumer
from exceptions import LogLineStreamFinishedException
from hadnlers import HighTrafficAlertHandler, TrafficStatsHandler
from producers import LocalCSVFileHttpLogProducer


class Dispatcher:
    """
    A class to represent dispatcher logic.
    Dispatcher start producers,
    consumers and handlers as asyncio tasks and manage their lifetime.
    """

    def __init__(self,
                 log_file_path: str = None):
        # init loop
        self._logger = logging.getLogger()

        # init local producer
        if log_file_path is None:
            log_file_path = Config.LOCAL_PRODUCER_FILEPATH
        self._producer = LocalCSVFileHttpLogProducer(log_file_path)

        # init consumers
        self._notification_consumer = ConsoleNotificationConsumer()

        # init handlers
        self._handlers = [
            HighTrafficAlertHandler(
                notification_consumer=self._notification_consumer,
                log_handler_queue=asyncio.Queue()
            ),
            TrafficStatsHandler(
                notification_consumer=self._notification_consumer,
                log_handler_queue=asyncio.Queue()
            )
        ]

    async def _handle_logs(self) -> None:
        """
        Iterate over stream of logs which are generated by producer.
        Handle each log by each handler
        """
        try:
            # iterate over stream and try to handle data
            async for log_line in self._producer.stream_logs():
                for handler in self._handlers:
                    await handler.handle(log_line)

        # in any case wait until each handler is fully processed
        finally:
            for handler in self._handlers:
                await handler.join()

            self._logger.debug("All handlers are joined")

        # All logs are handled, close all tasks by rising exception
        raise LogLineStreamFinishedException()

    async def _start_all(self) -> None:
        """
        Start all tasks in parallel mode
        """
        async with asyncio.TaskGroup() as tg:
            # generate workers array: Producer, Consumers and Handlers
            workers = [self._producer.start,
                       self._notification_consumer.start,
                       self._handle_logs]
            workers.extend([handler.start for handler in self._handlers])

            # run all workers in parallel mode
            for worker in workers:
                tg.create_task(worker())

    def run(self) -> None:
        """
        Start dispatcher
        """
        # start all workers
        try:
            asyncio.run(self._start_all())

        # tasks were stopped by user
        except KeyboardInterrupt:
            self._logger.debug(
                "Monitoring program was stopped by user. Quitting..."
            )

        # tasks were stopped because log stream finished
        except BaseExceptionGroup:
            self._logger.debug("All logs were proceed.")

        # finished message
        finally:
            self._logger.debug("Monitoring program finished.")
